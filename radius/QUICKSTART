= Radius Quick Start



== Defining Tags

Before you can parse a template with Radius you need to create a Context object which defines
the tags that will be used in the template. This is actually quite simple:

  require 'radius'
  
  context = Context.new do |c|
    c.define_tag "hello" do |tag|
      "Hello #{tag.attr['name'] || 'World'}!"
    end
  end

Once you have defined a context you can easily create a Parser:

  parser = Radius::Parser.new(context)
  puts parser.parse('<p><radius:hello /></p>')
  puts parser.parse('<p><radius:hello name="John" /></p>')

This code will output:

  <p>Hello World!</p>
  <p>Hello John!</p>

Note how you can pass attributes from the template to the context using the attributes hash.
Above, the first tag that was parsed didn't have a name attribute so the code in the +hello+
tag definition uses "World" instead. The second time the tag is parsed the name attribute is
set to "John" which is used to create the string "Hello John!". Tags that do not follow this
rule will be treated as if they were undefined (like normal methods).



== Container Tags

Radius also allows you to define "container" tags. That is, tags that contain content and
that may optionally manipulate it in some way. For example, if you have RedCloth installed
you could define another tag to parse and create Textile output:

  require 'redcloth'
  
  context.with do |c|
    c.define_tag "textile" do |tag|
      contents = tag.expand
      RedCloth.new(contents).to_html
    end
  end

(The code <tt>tag.expand</tt> above returns the contents of the template between the start and end
tags.)

With the code above your parser can easily handle Textile:

  parser.parse('<radius:textile>h1. Hello **World**!</radius:textile>')

This code will output:

  <h1>Hello <strong>World</strong>!</h1>



== Nesting Tags

But wait!--it gets better. Because container tags can manipulate the content they contain
you can use them to iterate over collections:

  context = Context.new do |c|
    c.define_tag "stooge" do |tag|
      content = ''
      ["Larry", "Moe", "Curly"].each do |name|
        tag.locals.name = name
        content << tag.expand
      end
      content
    end
    define_tag "stooge:name" do
      tag.locals.name
    end
  end
  
  parser = Radius::Parser.new(context)
  
  template = <<-TEMPLATE
  <ul>
  <radius:stooge>
    <li><radius:name /></li>
  </radius:stooge>
  </ul>
  TEMPLATE
  
  puts parser.parse(template)
  
This code will output:

  <ul>
  
    <li>Larry</li>
  
    <li>Moe</li>
  
    <li>Curly</li>
  
  </ul>

Note how the definition for the +name+ tag is defined. Because "name" is prefixed
with "stooge:" the +name+ tag cannot appear outside the +stooge+ tag. Had it been defined
simply as "name" it would be valid anywhere, even outside the +stooge+ tag (which was
not what we wanted). Using the colon operator you can define tags with any amount of
hierarchal nesting.


== Exposing Objects to Your Templates

During normal operation, you will often want to expose certain objects to your templates.
Writing the tags to do this all by hand would be cumbersome of Radius did not provide
several mechanisms to make this easier. The first is a way of exposing objects as tags
on the context object. To expose an object simply call the +define_tag+
method with the +for+ option:

  c.define_tag "count", :for => 1

This would expose the object <tt>1</tt> to the template as the +count+ tag. It's basically the
equivalent of writing:

  c.define_tag("count") { 1 }

So far this doesn't save you a whole lot of typing, but suppose you want to expose certain
methods that are on that object? You could do this:

  c.define_tag "user", :for => user, :expose => [ :name, :age, :email ]
  
This will add a total of four tags to the context. One for the <tt>user</tt> variable, and
one for each of the three methods listed in the +expose+ clause. You could now get the user's
name inside your template like this:

  <radius:user><radius:name /></radius:user>

If "John" was the value stored in <tt>@user.name</tt> the template would render as "John".



== Tag Shorthand ==

In the example above we made reference to the <tt>user.name</tt> variable in our template by
using the following code:

  <radius:user><radius:name /></radius:user>
  
There is a much easer way to refer to the <tt>user.name</tt> variable. Use the colon operator
to "scope" the reference to <tt>name</tt>:

  <radius:user:name />

Radius allows you to use this shortcut with most tags.
  


== Altering the Tag Prefix

By default, all Radius tags must begin with "radius". You can change this by altering the
tag_prefix attribute on a Parser. For example:

  parser = Radius::Parser.new(context, :tag_prefix => 'r')

Now, when parsing templates with +parser+, Radius will require that every tag begin with "r"
instead of "radius".



== Using Context#tag_missing to Define Behavior for Missing Tags

Context#tag_missing behaves much like Object#method_missing only it allows you to define
specific behavior for when a tag is not defined on a Context. For example:

  class LazyContext < Radius::Context
    def tag_missing(tag, attr, &block)
      "<strong>ERROR: Undefined tag `#{tag}' with attributes #{attr.inspect}</strong>"
    end
  end
  
  parser = Radius::Parser.new(LazyContext.new, :tag_prefix => 'lazy')
  puts parser.parse('<lazy:weird value="true" />')

This code will output:

  <strong>ERROR: Undefined tag `weird' with attributes {"value"=>"true"}</strong>

Normally, when the Radius Parser encounters an undefined tag for a Context it raises an
UndefinedTagError, but since we have defined #tag_missing on LazyContext the Parser now
outputs a nicely formated error message when we parse a string that does not contain a
valid tag.