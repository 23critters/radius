=DSL Specification

I haven't implemented a domain specific languages for Contexts yet, but I am hoping to
do so in a future release. Below are some thoughts (in code) for how I would like it to
work. Note that with a robust DSL you will be able to define that certain tags are
only valid within certain containing tags.

  class StoreContext < Radius::Context
    def initialize(options)
      @prefix = "r" # all tags must be prefixed with "r"
      @user = options[:user]
      @cart = options[:cart]
      @session = options[:session]
    end
  
    # expose the @user object variable
    container(:user, :exposes => :user) do
      # Use protect() on an object that has been exposed to prevent access to
      # an attribute in a template. Conversely you could use the expose() method
      # to expose specific attributes to the template and protect all others.
      protect :password
    
      # add a single tag that returns the session_id
      tag :session_id do |attributes|
        @session.id
      end
    end
  
    # expose the @cart object as the basket tag
    container(:basket, :exposes => :cart) do
      expand do |attributes|
        #
        # some initialization code with attributes before handling
        # content block
        #
        yeild
      end
    
      container(:items, :exposes => :item) do
        expand do |attributes|
          @cart.items.each do |@item|
            yield
          end
        end
      end
    end
  
    container :cart do
      expand do |attributes|
        yield
      end
    end
  end

  class User
    attr_accessor :name, :login, :password, :email
    def initialize(name, login, password, email)
      @name, @login, @password, @email = name, login, password, email
    end
  end

  class Session
    attr_accessor :id
    def initialize(id)
      @id = id
    end
  end

  class Cart
    attr_accessor :items
  
    def initialize(*items)
      @items = [items].flatten
    end
  
    def total
      @items.map { |line_item| line_item.total }
    end
  end

  class LineItem
    attr_accessor :name, :description, :quantity, :item_price
    def intialize(name, description, price, quantity)
      @name, @description, @price, @quantity = name, description, price, quantity
    end
    def full_price
      @price * @quantity
    end
  end

  receipt = <<-RECEIPT
  <p><r:user:name />, thank you for shopping with us! An order summary
    is printed below for your convinience. Please print a copy for your records.</p>
  <r:cart>
    <table>
      <thead>
        <tr>
          <td>Product</td>
          <td>Price</td>
          <td>Quantity</td>
          <td>Totals</td>
        </tr>
      </thead>
      <tbody>
        <r:items>
          <tr>
            <td>
              <strong><r:name /></strong><br >
              <r:description />
            </td>
            <td><r:price /></td>
            <td><r:quanity /></td>
            <td><r:full_price /></td>
          </tr>
        </r:items>
      </tbody>
      <tr>
        <td colspan="3">Total</td>
        <td><r:total /></td>
      </tr>
    </table>
  </r:cart>
  RECEIPT

  user = User.new('John', 'johnboy', 'm@x!mu5', 'johnboy@maximus.com')
  cart = Cart.new(
    LineItem.new('15in PowerBook', "Apple's premium notebook computer.", 1995.98, 1),
    LineItem.new('Mac Notebook Case', "A beautiful black notebook case designed for Apple Powerbooks.", 54.05, 1)
  )
  session = Session.new('a4bd386e512bacd581')

  context = StoreContext.new(
    :user => user,
    :cart => cart,
    :session => session
  )

  template = Radius::Template.new(
    :text => receipt,
    :context => context
  )

  template.compile! # based on context parses text into abstract syntax tree
  puts template.expand # outputs expanded template

  # alternate usage
  parser = Radius::Parser.new(context)
  puts parser.parse(receipt) # compiles and outputs expanded template

  # another alternate
  puts Radius.parse(receipt, context)